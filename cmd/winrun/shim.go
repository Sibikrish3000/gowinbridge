package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

const shimTemplate = `#!/bin/sh
# Generated by winrun shim install
# Binary: %s
exec winrun --convert-paths -- %s "$@"
`

// handleShim processes the "shim" subcommand.
// Usage:
//
//	winrun shim install <binary.exe> --as <name> [--bin-dir PATH]
//	winrun shim list [--bin-dir PATH]
//	winrun shim remove <name> [--bin-dir PATH]
func handleShim(args []string) {
	if len(args) == 0 {
		fmt.Fprintln(os.Stderr, "Usage: winrun shim <install|list|remove> [options]")
		os.Exit(1)
	}

	subCmd := args[0]
	subArgs := args[1:]

	switch subCmd {
	case "install":
		shimInstall(subArgs)
	case "list":
		shimList(subArgs)
	case "remove":
		shimRemove(subArgs)
	default:
		fmt.Fprintf(os.Stderr, "Unknown shim command: %q\n", subCmd)
		fmt.Fprintln(os.Stderr, "Usage: winrun shim <install|list|remove> [options]")
		os.Exit(1)
	}
}

func defaultBinDir() string {
	home, err := os.UserHomeDir()
	if err != nil {
		return "/usr/local/bin"
	}
	return filepath.Join(home, ".local", "bin")
}

func shimInstall(args []string) {
	fs := flag.NewFlagSet("shim install", flag.ExitOnError)
	asName := fs.String("as", "", "Name for the shim (required)")
	binDir := fs.String("bin-dir", defaultBinDir(), "Directory to install the shim script")
	fs.Parse(args)

	if fs.NArg() == 0 {
		fmt.Fprintln(os.Stderr, "Usage: winrun shim install <binary.exe> --as <name> [--bin-dir PATH]")
		os.Exit(1)
	}

	binary := fs.Arg(0)
	name := *asName
	if name == "" {
		// Auto-derive name from binary: "docker.exe" → "docker"
		name = strings.TrimSuffix(filepath.Base(binary), ".exe")
	}

	// Ensure bin directory exists.
	if err := os.MkdirAll(*binDir, 0o755); err != nil {
		fmt.Fprintf(os.Stderr, "Error creating bin directory %q: %v\n", *binDir, err)
		os.Exit(1)
	}

	shimPath := filepath.Join(*binDir, name)
	content := fmt.Sprintf(shimTemplate, binary, binary)

	if err := os.WriteFile(shimPath, []byte(content), 0o755); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing shim %q: %v\n", shimPath, err)
		os.Exit(1)
	}

	fmt.Printf("Shim installed: %s → %s\n", shimPath, binary)
	fmt.Printf("Make sure %s is in your PATH.\n", *binDir)
}

func shimList(args []string) {
	fs := flag.NewFlagSet("shim list", flag.ExitOnError)
	binDir := fs.String("bin-dir", defaultBinDir(), "Directory to search for shims")
	fs.Parse(args)

	entries, err := os.ReadDir(*binDir)
	if err != nil {
		if os.IsNotExist(err) {
			fmt.Println("No shims installed.")
			return
		}
		fmt.Fprintf(os.Stderr, "Error reading %q: %v\n", *binDir, err)
		os.Exit(1)
	}

	found := 0
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		shimPath := filepath.Join(*binDir, entry.Name())
		content, err := os.ReadFile(shimPath)
		if err != nil {
			continue
		}
		if strings.Contains(string(content), "Generated by winrun shim install") {
			// Extract the binary name from the script.
			lines := strings.Split(string(content), "\n")
			binary := "unknown"
			for _, line := range lines {
				if strings.HasPrefix(line, "# Binary: ") {
					binary = strings.TrimPrefix(line, "# Binary: ")
					break
				}
			}
			fmt.Printf("  %s → %s\n", entry.Name(), binary)
			found++
		}
	}

	if found == 0 {
		fmt.Println("No shims installed.")
	} else {
		fmt.Printf("\n%d shim(s) found in %s\n", found, *binDir)
	}
}

func shimRemove(args []string) {
	fs := flag.NewFlagSet("shim remove", flag.ExitOnError)
	binDir := fs.String("bin-dir", defaultBinDir(), "Directory containing the shim")
	fs.Parse(args)

	if fs.NArg() == 0 {
		fmt.Fprintln(os.Stderr, "Usage: winrun shim remove <name> [--bin-dir PATH]")
		os.Exit(1)
	}

	name := fs.Arg(0)
	shimPath := filepath.Join(*binDir, name)

	// Verify it's actually a winrun shim before removing.
	content, err := os.ReadFile(shimPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: shim %q not found: %v\n", shimPath, err)
		os.Exit(1)
	}

	if !strings.Contains(string(content), "Generated by winrun shim install") {
		fmt.Fprintf(os.Stderr, "Error: %q is not a winrun shim. Refusing to remove.\n", shimPath)
		os.Exit(1)
	}

	if err := os.Remove(shimPath); err != nil {
		fmt.Fprintf(os.Stderr, "Error removing shim %q: %v\n", shimPath, err)
		os.Exit(1)
	}

	fmt.Printf("Shim removed: %s\n", shimPath)
}

// generateShimScript produces the shell script content for a shim.
// Exported for testing.
func generateShimScript(binary string) string {
	return fmt.Sprintf(shimTemplate, binary, binary)
}
